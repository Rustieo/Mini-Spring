<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/minis/aop/ProxyCreator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/minis/aop/ProxyCreator.java" />
              <option name="originalContent" value="package com.minis.aop;&#10;&#10;import com.minis.beans.BeansException;&#10;import com.minis.beans.PropertyValues;&#10;import com.minis.beans.factory.BeanFactory;&#10;import com.minis.beans.factory.FactoryBean;&#10;import com.minis.beans.factory.config.SmartInstantiationAwareBeanPostProcessor;&#10;import com.minis.beans.factory.support.DefaultListableBeanFactory;&#10;import com.minis.utils.AopUtils;&#10;import com.minis.utils.StringUtils;&#10;import lombok.Data;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;@Slf4j&#10;@Data&#10;public class ProxyCreator implements SmartInstantiationAwareBeanPostProcessor {&#10;    protected static final Object[] DO_NOT_PROXY = null;&#10;    private String pattern;&#10;    //记录的是全局拦截器,不包括特定bean的拦截器&#10;    String[] interceptorNames;&#10;    private AopProxyFactory aopProxyFactory;&#10;    DefaultListableBeanFactory beanFactory;&#10;    List&lt;Advisor&gt; advisorsCache;&#10;    //用于缓存在循环依赖中提前被代理的对象&#10;    private final Map&lt;Object, Object&gt; earlyProxyReferences = new ConcurrentHashMap&lt;&gt;(16);&#10;    public ProxyCreator(){&#10;        //TODO 因为目前xml还没定义数组,因此只能先这么搞了(笑)&#10;        this.aopProxyFactory = new DefaultAopProxyFactory();&#10;        this.interceptorNames=new String[]{&quot;myInterceptor&quot;};&#10;    }&#10;    public ProxyCreator(String[] interceptorNames) {&#10;        this.interceptorNames = interceptorNames;&#10;        this.aopProxyFactory = new DefaultAopProxyFactory();&#10;    }&#10;    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {&#10;        return pvs;&#10;    }&#10;    @Override&#10;    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {&#10;        return bean;&#10;    }&#10;    @Override&#10;    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {&#10;        if (bean != null) {&#10;            //检查这个bean是否在解决循环依赖时已经被代理过了&#10;            Object cacheKey = getCacheKey(bean.getClass(), beanName);&#10;            if (this.earlyProxyReferences.remove(cacheKey) != bean) {&#10;                return wrapIfNecessary(bean, beanName, cacheKey);&#10;            }&#10;        }&#10;        return bean;&#10;    }&#10;&#10;    public Object wrapIfNecessary(Object bean,String beanName,Object cacheKey){&#10;        //跳过AOP基础设施类，不进行代理&#10;        if (isInfrastructureClass(bean.getClass())) {&#10;            return bean;&#10;        }&#10;        //获取一个Bean的所有Advisor&#10;        Object[] advisors = getAdvicesAndAdvisorsForBean(beanName,bean.getClass());&#10;        if(advisors==DO_NOT_PROXY){&#10;            return bean;&#10;        }&#10;        log.info(&quot;AOP匹配成功,Bean名称:{}&quot;,beanName);&#10;        //创建代理&#10;        List&lt;PointcutAdvisor&gt;advisorsList=new ArrayList&lt;&gt;();&#10;        for (Object advisor : advisors) {&#10;            advisorsList.add((PointcutAdvisor) advisor);&#10;        }&#10;        /*ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();&#10;        proxyFactoryBean.setTarget(bean);&#10;        proxyFactoryBean.setBeanFactory(this.beanFactory);&#10;        //proxyFactoryBean.setAdvisors(advisorsList);&#10;        proxyFactoryBean.setAopProxyFactory(this.aopProxyFactory);*/&#10;        ProxyFactory proxyFactory=new ProxyFactory(bean);&#10;        proxyFactory.setAdvisors(advisorsList);&#10;        proxyFactory.setAopProxyFactory(this.aopProxyFactory);&#10;        return proxyFactory.getProxy();&#10;    }&#10;&#10;&#10;    //获取一个Bean最终要用的Advisor&#10;    private Object[] getAdvicesAndAdvisorsForBean(String beanName,Class&lt;?&gt; beanClass) {&#10;        List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanName,beanClass);&#10;        return advisors.isEmpty() ? DO_NOT_PROXY:advisors.toArray(new Advisor[0]);&#10;    }&#10;    private List&lt;Advisor&gt; findEligibleAdvisors(String beanName, Class&lt;?&gt; beanClass){&#10;        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(beanName,beanClass);&#10;        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors,beanClass);&#10;        return eligibleAdvisors;&#10;    }&#10;    //获取作用于特定Bean的动态的Advisor(在Spring中)&#10;    //然后另一个方法:resolveInterceptorNames是用来获取配置文件中的advisor,是全局的,固定好的&#10;    //但是minis只能通过配置文件来注册Advisor(笑)&#10;    private List&lt;Advisor&gt; findCandidateAdvisors(String beanName,Class&lt;?&gt; beanClass) {&#10;        if (advisorsCache != null) {&#10;            return advisorsCache;&#10;        }&#10;        List&lt;Advisor&gt; advisors=new ArrayList&lt;&gt;();&#10;        advisors.addAll(this.beanFactory.getBeansOfType(Advisor.class).values());&#10;        advisorsCache=advisors;&#10;        return advisors;&#10;    }&#10;    //判断Advisor是否适用于特定的Bean&#10;    private List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass) {&#10;        List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;();&#10;        for (Advisor advisor : candidateAdvisors) {&#10;            if (advisor instanceof PointcutAdvisor) {&#10;                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;&#10;                if(pointcutAdvisor instanceof PointcutAdvisor){&#10;                    //TODO 这里为啥莫名其妙空着了&#10;&#10;                }&#10;                //检查切点和该类是否匹配&#10;                if(AopUtils.canApply(pointcutAdvisor,beanClass)){&#10;                    //匹配成功,说明该类有需要被代理的方法(minis目前只能实现方法的代理)&#10;                    eligibleAdvisors.add(advisor);&#10;                }&#10;            }&#10;        }&#10;        return eligibleAdvisors;&#10;    }&#10;&#10;    @Override&#10;    public Object getEarlyBeanReference(Object bean, String beanName) {&#10;        // 跳过AOP基础设施类，避免在收集Advisor时再次走代理导致递归&#10;        if (isInfrastructureClass(bean.getClass())) {&#10;            return bean;&#10;        }&#10;        Object cacheKey = getCacheKey(bean.getClass(), beanName);&#10;        this.earlyProxyReferences.put(cacheKey, bean);&#10;        return wrapIfNecessary(bean, beanName, cacheKey);&#10;    }&#10;&#10;    protected Object getCacheKey(Class&lt;?&gt; beanClass,String beanName) {&#10;        if (StringUtils.hasLength(beanName)) {&#10;            return (FactoryBean.class.isAssignableFrom(beanClass) ?&#10;                    BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);&#10;        }&#10;        else {&#10;            return beanClass;&#10;        }&#10;    }&#10;    public boolean isInfrastructureClass(Class&lt;?&gt; beanClass) {&#10;        boolean retVal = Advice.class.isAssignableFrom(beanClass) ||&#10;                Pointcut.class.isAssignableFrom(beanClass) ||&#10;                Advisor.class.isAssignableFrom(beanClass);&#10;        return retVal;&#10;    }&#10;&#10;    @Override&#10;    public void setBeanFactory(BeanFactory beanFactory) {&#10;        this.beanFactory = (DefaultListableBeanFactory) beanFactory;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.minis.aop;&#10;&#10;import com.minis.beans.BeansException;&#10;import com.minis.beans.PropertyValues;&#10;import com.minis.beans.factory.BeanFactory;&#10;import com.minis.beans.factory.FactoryBean;&#10;import com.minis.beans.factory.config.SmartInstantiationAwareBeanPostProcessor;&#10;import com.minis.beans.factory.support.DefaultListableBeanFactory;&#10;import com.minis.utils.AopUtils;&#10;import com.minis.utils.StringUtils;&#10;import lombok.Data;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;@Slf4j&#10;@Data&#10;public class ProxyCreator implements SmartInstantiationAwareBeanPostProcessor {&#10;    protected static final Object[] DO_NOT_PROXY = null;&#10;    private String pattern;&#10;    //记录的是全局拦截器,不包括特定bean的拦截器&#10;    String[] interceptorNames;&#10;    private AopProxyFactory aopProxyFactory;&#10;    DefaultListableBeanFactory beanFactory;&#10;    List&lt;Advisor&gt; advisorsCache;&#10;    //用于缓存在循环依赖中提前被代理的对象&#10;    private final Map&lt;Object, Object&gt; earlyProxyReferences = new ConcurrentHashMap&lt;&gt;(16);&#10;    public ProxyCreator(){&#10;        //TODO 因为目前xml还没定义数组,因此只能先这么搞了(笑)&#10;        this.aopProxyFactory = new DefaultAopProxyFactory();&#10;        this.interceptorNames=new String[]{&quot;myInterceptor&quot;};&#10;    }&#10;    public ProxyCreator(String[] interceptorNames) {&#10;        this.interceptorNames = interceptorNames;&#10;        this.aopProxyFactory = new DefaultAopProxyFactory();&#10;    }&#10;    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {&#10;        return pvs;&#10;    }&#10;    @Override&#10;    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {&#10;        return bean;&#10;    }&#10;    @Override&#10;    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {&#10;        if (bean != null) {&#10;            //检查这个bean是否在解决循环依赖时已经被代理过了&#10;            Object cacheKey = getCacheKey(bean.getClass(), beanName);&#10;            if (this.earlyProxyReferences.remove(cacheKey) != bean) {&#10;                return wrapIfNecessary(bean, beanName, cacheKey);&#10;            }&#10;        }&#10;        return bean;&#10;    }&#10;&#10;    public Object wrapIfNecessary(Object bean,String beanName,Object cacheKey){&#10;        //跳过AOP基础设施类，不进行代理&#10;        if (isInfrastructureClass(bean.getClass())) {&#10;            return bean;&#10;        }&#10;        //获取一个Bean的所有Advisor&#10;        Object[] advisors = getAdvicesAndAdvisorsForBean(beanName,bean.getClass());&#10;        if(advisors==DO_NOT_PROXY){&#10;            return bean;&#10;        }&#10;        log.info(&quot;AOP匹配成功,Bean名称:{}&quot;,beanName);&#10;        //创建代理&#10;        List&lt;PointcutAdvisor&gt;advisorsList=new ArrayList&lt;&gt;();&#10;        for (Object advisor : advisors) {&#10;            advisorsList.add((PointcutAdvisor) advisor);&#10;        }&#10;        /*ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();&#10;        proxyFactoryBean.setTarget(bean);&#10;        proxyFactoryBean.setBeanFactory(this.beanFactory);&#10;        //proxyFactoryBean.setAdvisors(advisorsList);&#10;        proxyFactoryBean.setAopProxyFactory(this.aopProxyFactory);*/&#10;        ProxyFactory proxyFactory=new ProxyFactory(bean);&#10;        proxyFactory.setAdvisors(advisorsList);&#10;        proxyFactory.setAopProxyFactory(this.aopProxyFactory);&#10;        return proxyFactory.getProxy();&#10;    }&#10;&#10;&#10;    //获取一个Bean最终要用的Advisor&#10;    private Object[] getAdvicesAndAdvisorsForBean(String beanName,Class&lt;?&gt; beanClass) {&#10;        List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanName,beanClass);&#10;        return advisors.isEmpty() ? DO_NOT_PROXY:advisors.toArray(new Advisor[0]);&#10;    }&#10;    private List&lt;Advisor&gt; findEligibleAdvisors(String beanName, Class&lt;?&gt; beanClass){&#10;        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(beanName,beanClass);&#10;        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors,beanClass);&#10;        return eligibleAdvisors;&#10;    }&#10;    //获取作用于特定Bean的动态的Advisor(在Spring中)&#10;    //然后另一个方法:resolveInterceptorNames是用来获取配置文件中的advisor,是全局的,固定好的&#10;    //但是minis只能通过配置文件来注册Advisor(笑)&#10;    private List&lt;Advisor&gt; findCandidateAdvisors(String beanName,Class&lt;?&gt; beanClass) {&#10;        if (advisorsCache != null) {&#10;            return advisorsCache;&#10;        }&#10;        List&lt;Advisor&gt; advisors=new ArrayList&lt;&gt;();&#10;        advisors.addAll(this.beanFactory.getBeansOfType(Advisor.class).values());&#10;        advisorsCache=advisors;&#10;        return advisors;&#10;    }&#10;    //判断Advisor是否适用于特定的Bean&#10;    private List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass) {&#10;        List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;();&#10;        for (Advisor advisor : candidateAdvisors) {&#10;            if (advisor instanceof PointcutAdvisor) {&#10;                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;&#10;                if(pointcutAdvisor instanceof PointcutAdvisor){&#10;                    //TODO 这里为啥莫名其妙空着了&#10;&#10;                }&#10;                //检查切点和该类是否匹配&#10;                if(AopUtils.canApply(pointcutAdvisor,beanClass)){&#10;                    //匹配成功,说明该类有需要被代理的方法(minis目前只能实现方法的代理)&#10;                    eligibleAdvisors.add(advisor);&#10;                }&#10;            }&#10;        }&#10;        return eligibleAdvisors;&#10;    }&#10;&#10;    @Override&#10;    public Object getEarlyBeanReference(Object bean, String beanName) {&#10;        // 跳过AOP基础设施类，避免在收集Advisor时再次走代理导致递归&#10;        if (isInfrastructureClass(bean.getClass())) {&#10;            return bean;&#10;        }&#10;        Object cacheKey = getCacheKey(bean.getClass(), beanName);&#10;        this.earlyProxyReferences.put(cacheKey, bean);&#10;        return wrapIfNecessary(bean, beanName, cacheKey);&#10;    }&#10;&#10;    protected Object getCacheKey(Class&lt;?&gt; beanClass,String beanName) {&#10;        if (StringUtils.hasLength(beanName)) {&#10;            return (FactoryBean.class.isAssignableFrom(beanClass) ?&#10;                    BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);&#10;        }&#10;        else {&#10;            return beanClass;&#10;        }&#10;    }&#10;    public boolean isInfrastructureClass(Class&lt;?&gt; beanClass) {&#10;        boolean retVal = Advice.class.isAssignableFrom(beanClass) ||&#10;                Pointcut.class.isAssignableFrom(beanClass) ||&#10;                Advisor.class.isAssignableFrom(beanClass);&#10;        return retVal;&#10;    }&#10;&#10;    @Override&#10;    public void setBeanFactory(BeanFactory beanFactory) {&#10;        this.beanFactory = (DefaultListableBeanFactory) beanFactory;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/applicationContext.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/applicationContext.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&#10;&lt;beans&gt;&#10;    &lt;bean id=&quot;autoProxyCreator&quot; class=&quot;com.minis.aop.ProxyCreator&quot; &gt;&#10;&#10;&#10;    &lt;/bean&gt;&#10;    &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.minis.test.service.MyBeforeAdvice&quot; /&gt;&#10;    &lt;bean id=&quot;advisor&quot; class=&quot;com.minis.aop.NameMatchMethodPointcutAdvisor&quot;&gt;&#10;        &lt;property type=&quot;com.minis.aop.Advice&quot; name=&quot;advice&quot; ref=&quot;beforeAdvice&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;mappedName&quot; value=&quot;does*&quot;/&gt;&#10;    &lt;/bean&gt;&#10;    &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.minis.test.service.TracingInterceptor&quot; /&gt;&#10;    &lt;bean id=&quot;realaction&quot; class=&quot;com.minis.test.service.Action1&quot; /&gt;&#10;&#10;    &lt;bean id=&quot;baseBaseService&quot; class=&quot;com.minis.test.BaseBaseService&quot;&gt;&#10;        &lt;property type=&quot;com.minis.test.AServiceImpl&quot; name=&quot;as&quot; ref=&quot;aService&quot; /&gt;&#10;    &lt;/bean&gt;&#10;    &lt;bean id=&quot;aService&quot; class=&quot;com.minis.test.AServiceImpl&quot;&gt;&#10;        &lt;constructor-arg type=&quot;String&quot; name=&quot;name&quot; value=&quot;abc&quot;/&gt;&#10;        &lt;constructor-arg type=&quot;int&quot; name=&quot;level&quot; value=&quot;3&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;property1&quot; value=&quot;Someone says&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;property2&quot; value=&quot;Hello World!&quot;/&gt;&#10;        &lt;!--        &lt;property type=&quot;com.minis.test.BaseService&quot; name=&quot;ref1&quot; ref=&quot;baseService&quot;/&gt;--&gt;&#10;    &lt;/bean&gt;&#10;    &lt;bean id=&quot;baseService&quot; class=&quot;com.minis.test.BaseService&quot;&gt;&#10;    &lt;/bean&gt;&#10;&#10;&#10;&lt;!--    &lt;bean id=&quot;action&quot; class=&quot;com.minis.aop.ProxyFactoryBean&quot; &gt;--&gt;&#10;&lt;!--        &lt;property type=&quot;java.lang.Object&quot; name=&quot;target&quot; ref=&quot;realaction&quot;/&gt;--&gt;&#10;&lt;!--    &lt;/bean&gt;--&gt;&#10;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.minis.jdbc.datasource.SingleConnectionDataSource&quot;&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;driverClassName&quot; value=&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;url&quot; value=&quot;jdbc:sqlserver://localhost:1433;databasename=DEMO;&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;username&quot; value=&quot;sa&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;password&quot; value=&quot;Sql2016&quot;/&gt;&#10;    &lt;/bean&gt;&#10;    &lt;bean id=&quot;webBindingInitializer&quot; class=&quot;com.minis.test.DateInitializer&quot;&gt;&#10;    &lt;/bean&gt;&#10;&#10;&#10;&#10;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;com.minis.jdbc.core.JdbcTemplate&quot; &gt;&#10;        &lt;property type=&quot;javax.sql.DataSource&quot; name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&#10;    &lt;/bean&gt;&#10;&#10;&#10;&lt;/beans&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&#13;&#10;&lt;beans&gt;&#13;&#10;    &lt;bean id=&quot;autoProxyCreator&quot; class=&quot;com.minis.aop.ProxyCreator&quot; &gt;&#13;&#10;&#13;&#10;&#13;&#10;    &lt;/bean&gt;&#13;&#10;    &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.minis.test.service.MyBeforeAdvice&quot; /&gt;&#13;&#10;    &lt;bean id=&quot;advisor&quot; class=&quot;com.minis.aop.NameMatchMethodPointcutAdvisor&quot;&gt;&#13;&#10;        &lt;property type=&quot;com.minis.aop.Advice&quot; name=&quot;advice&quot; ref=&quot;beforeAdvice&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;mappedName&quot; value=&quot;does*&quot;/&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;    &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.minis.test.service.TracingInterceptor&quot; /&gt;&#13;&#10;    &lt;bean id=&quot;realaction&quot; class=&quot;com.minis.test.service.Action1&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;bean id=&quot;baseBaseService&quot; class=&quot;com.minis.test.BaseBaseService&quot;&gt;&#13;&#10;        &lt;property type=&quot;com.minis.test.AServiceImpl&quot; name=&quot;as&quot; ref=&quot;aService&quot; /&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;    &lt;bean id=&quot;aService&quot; class=&quot;com.minis.test.AServiceImpl&quot;&gt;&#13;&#10;        &lt;constructor-arg type=&quot;String&quot; name=&quot;name&quot; value=&quot;abc&quot;/&gt;&#13;&#10;        &lt;constructor-arg type=&quot;int&quot; name=&quot;level&quot; value=&quot;3&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;property1&quot; value=&quot;Someone says&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;property2&quot; value=&quot;Hello World!&quot;/&gt;&#13;&#10;        &lt;!--        &lt;property type=&quot;com.minis.test.BaseService&quot; name=&quot;ref1&quot; ref=&quot;baseService&quot;/&gt;--&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;    &lt;bean id=&quot;baseService&quot; class=&quot;com.minis.test.BaseService&quot;&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;&#13;&#10;&#13;&#10;&lt;!--    &lt;bean id=&quot;action&quot; class=&quot;com.minis.aop.ProxyFactoryBean&quot; &gt;--&gt;&#13;&#10;&lt;!--        &lt;property type=&quot;java.lang.Object&quot; name=&quot;target&quot; ref=&quot;realaction&quot;/&gt;--&gt;&#13;&#10;&lt;!--    &lt;/bean&gt;--&gt;&#13;&#10;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.minis.jdbc.datasource.SingleConnectionDataSource&quot;&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;driverClassName&quot; value=&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;url&quot; value=&quot;jdbc:sqlserver://localhost:1433;databasename=DEMO;&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;username&quot; value=&quot;sa&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;password&quot; value=&quot;Sql2016&quot;/&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;    &lt;bean id=&quot;webBindingInitializer&quot; class=&quot;com.minis.test.DateInitializer&quot;&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;com.minis.jdbc.core.JdbcTemplate&quot; &gt;&#13;&#10;        &lt;property type=&quot;javax.sql.DataSource&quot; name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;&#13;&#10;&#13;&#10;&lt;/beans&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>