<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/minis/aop/ProxyCreator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/minis/aop/ProxyCreator.java" />
              <option name="originalContent" value="package com.minis.aop;&#10;&#10;import com.minis.beans.BeansException;&#10;import com.minis.beans.PropertyValues;&#10;import com.minis.beans.factory.BeanFactory;&#10;import com.minis.beans.factory.FactoryBean;&#10;import com.minis.beans.factory.config.SmartInstantiationAwareBeanPostProcessor;&#10;import com.minis.beans.factory.support.DefaultListableBeanFactory;&#10;import com.minis.utils.AopUtils;&#10;import com.minis.utils.StringUtils;&#10;import lombok.Data;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;@Slf4j&#10;@Data&#10;public class ProxyCreator implements SmartInstantiationAwareBeanPostProcessor {&#10;    protected static final Object[] DO_NOT_PROXY = null;&#10;    private String pattern;&#10;    //记录的是全局拦截器,不包括特定bean的拦截器&#10;    String[] interceptorNames;&#10;    private AopProxyFactory aopProxyFactory;&#10;    DefaultListableBeanFactory beanFactory;&#10;    List&lt;Advisor&gt; advisorsCache;&#10;    //用于缓存在循环依赖中提前被代理的对象&#10;    private final Map&lt;Object, Object&gt; earlyProxyReferences = new ConcurrentHashMap&lt;&gt;(16);&#10;    public ProxyCreator(){&#10;        //TODO 因为目前xml还没定义数组,因此只能先这么搞了(笑)&#10;        this.aopProxyFactory = new DefaultAopProxyFactory();&#10;        this.interceptorNames=new String[]{&quot;myInterceptor&quot;};&#10;    }&#10;    public ProxyCreator(String[] interceptorNames) {&#10;        this.interceptorNames = interceptorNames;&#10;        this.aopProxyFactory = new DefaultAopProxyFactory();&#10;    }&#10;    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {&#10;        return pvs;&#10;    }&#10;    @Override&#10;    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {&#10;        return bean;&#10;    }&#10;    @Override&#10;    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {&#10;        if (bean != null) {&#10;            //检查这个bean是否在解决循环依赖时已经被代理过了&#10;            Object cacheKey = getCacheKey(bean.getClass(), beanName);&#10;            if (this.earlyProxyReferences.remove(cacheKey) != bean) {&#10;                return wrapIfNecessary(bean, beanName, cacheKey);&#10;            }&#10;        }&#10;        return bean;&#10;    }&#10;&#10;    public Object wrapIfNecessary(Object bean,String beanName,Object cacheKey){&#10;        //跳过AOP基础设施类，不进行代理&#10;        if (isInfrastructureClass(bean.getClass())) {&#10;            return bean;&#10;        }&#10;        //获取一个Bean的所有Advisor&#10;        Object[] advisors = getAdvicesAndAdvisorsForBean(beanName,bean.getClass());&#10;        if(advisors==DO_NOT_PROXY){&#10;            return bean;&#10;        }&#10;        log.info(&quot;AOP匹配成功,Bean名称:{}&quot;,beanName);&#10;        //创建代理&#10;        List&lt;PointcutAdvisor&gt;advisorsList=new ArrayList&lt;&gt;();&#10;        for (Object advisor : advisors) {&#10;            advisorsList.add((PointcutAdvisor) advisor);&#10;        }&#10;        /*ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();&#10;        proxyFactoryBean.setTarget(bean);&#10;        proxyFactoryBean.setBeanFactory(this.beanFactory);&#10;        //proxyFactoryBean.setAdvisors(advisorsList);&#10;        proxyFactoryBean.setAopProxyFactory(this.aopProxyFactory);*/&#10;        ProxyFactory proxyFactory=new ProxyFactory(bean);&#10;        proxyFactory.setAdvisors(advisorsList);&#10;        proxyFactory.setAopProxyFactory(this.aopProxyFactory);&#10;        return proxyFactory.getProxy();&#10;    }&#10;&#10;&#10;    //获取一个Bean最终要用的Advisor&#10;    private Object[] getAdvicesAndAdvisorsForBean(String beanName,Class&lt;?&gt; beanClass) {&#10;        List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanName,beanClass);&#10;        return advisors.isEmpty() ? DO_NOT_PROXY:advisors.toArray(new Advisor[0]);&#10;    }&#10;    private List&lt;Advisor&gt; findEligibleAdvisors(String beanName, Class&lt;?&gt; beanClass){&#10;        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(beanName,beanClass);&#10;        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors,beanClass);&#10;        return eligibleAdvisors;&#10;    }&#10;    //获取作用于特定Bean的动态的Advisor(在Spring中)&#10;    //然后另一个方法:resolveInterceptorNames是用来获取配置文件中的advisor,是全局的,固定好的&#10;    //但是minis只能通过配置文件来注册Advisor(笑)&#10;    private List&lt;Advisor&gt; findCandidateAdvisors(String beanName,Class&lt;?&gt; beanClass) {&#10;        if (advisorsCache != null) {&#10;            return advisorsCache;&#10;        }&#10;        List&lt;Advisor&gt; advisors=new ArrayList&lt;&gt;();&#10;        advisors.addAll(this.beanFactory.getBeansOfType(Advisor.class).values());&#10;        advisorsCache=advisors;&#10;        return advisors;&#10;    }&#10;    //判断Advisor是否适用于特定的Bean&#10;    private List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass) {&#10;        List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;();&#10;        for (Advisor advisor : candidateAdvisors) {&#10;            if (advisor instanceof PointcutAdvisor) {&#10;                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;&#10;                if(pointcutAdvisor instanceof PointcutAdvisor){&#10;                    //TODO 这里为啥莫名其妙空着了&#10;&#10;                }&#10;                //检查切点和该类是否匹配&#10;                if(AopUtils.canApply(pointcutAdvisor,beanClass)){&#10;                    //匹配成功,说明该类有需要被代理的方法(minis目前只能实现方法的代理)&#10;                    eligibleAdvisors.add(advisor);&#10;                }&#10;            }&#10;        }&#10;        return eligibleAdvisors;&#10;    }&#10;&#10;    @Override&#10;    public Object getEarlyBeanReference(Object bean, String beanName) {&#10;        // 跳过AOP基础设施类，避免在收集Advisor时再次走代理导致递归&#10;        if (isInfrastructureClass(bean.getClass())) {&#10;            return bean;&#10;        }&#10;        Object cacheKey = getCacheKey(bean.getClass(), beanName);&#10;        this.earlyProxyReferences.put(cacheKey, bean);&#10;        return wrapIfNecessary(bean, beanName, cacheKey);&#10;    }&#10;&#10;    protected Object getCacheKey(Class&lt;?&gt; beanClass,String beanName) {&#10;        if (StringUtils.hasLength(beanName)) {&#10;            return (FactoryBean.class.isAssignableFrom(beanClass) ?&#10;                    BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);&#10;        }&#10;        else {&#10;            return beanClass;&#10;        }&#10;    }&#10;    public boolean isInfrastructureClass(Class&lt;?&gt; beanClass) {&#10;        boolean retVal = Advice.class.isAssignableFrom(beanClass) ||&#10;                Pointcut.class.isAssignableFrom(beanClass) ||&#10;                Advisor.class.isAssignableFrom(beanClass);&#10;        return retVal;&#10;    }&#10;&#10;    @Override&#10;    public void setBeanFactory(BeanFactory beanFactory) {&#10;        this.beanFactory = (DefaultListableBeanFactory) beanFactory;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.minis.aop;&#10;&#10;import com.minis.beans.BeansException;&#10;import com.minis.beans.PropertyValues;&#10;import com.minis.beans.factory.BeanFactory;&#10;import com.minis.beans.factory.FactoryBean;&#10;import com.minis.beans.factory.config.SmartInstantiationAwareBeanPostProcessor;&#10;import com.minis.beans.factory.support.DefaultListableBeanFactory;&#10;import com.minis.utils.AopUtils;&#10;import com.minis.utils.StringUtils;&#10;import lombok.Data;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;@Slf4j&#10;@Data&#10;public class ProxyCreator implements SmartInstantiationAwareBeanPostProcessor {&#10;    protected static final Object[] DO_NOT_PROXY = null;&#10;    private String pattern;&#10;    //记录的是全局拦截器,不包括特定bean的拦截器&#10;    String[] interceptorNames;&#10;    private AopProxyFactory aopProxyFactory;&#10;    DefaultListableBeanFactory beanFactory;&#10;    List&lt;Advisor&gt; advisorsCache;&#10;    //用于缓存在循环依赖中提前被代理的对象&#10;    private final Map&lt;Object, Object&gt; earlyProxyReferences = new ConcurrentHashMap&lt;&gt;(16);&#10;    public ProxyCreator(){&#10;        //TODO 因为目前xml还没定义数组,因此只能先这么搞了(笑)&#10;        this.aopProxyFactory = new DefaultAopProxyFactory();&#10;        this.interceptorNames=new String[]{&quot;myInterceptor&quot;};&#10;    }&#10;    public ProxyCreator(String[] interceptorNames) {&#10;        this.interceptorNames = interceptorNames;&#10;        this.aopProxyFactory = new DefaultAopProxyFactory();&#10;    }&#10;    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {&#10;        return pvs;&#10;    }&#10;    @Override&#10;    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {&#10;        return bean;&#10;    }&#10;    @Override&#10;    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {&#10;        if (bean != null) {&#10;            //检查这个bean是否在解决循环依赖时已经被代理过了&#10;            Object cacheKey = getCacheKey(bean.getClass(), beanName);&#10;            if (this.earlyProxyReferences.remove(cacheKey) != bean) {&#10;                return wrapIfNecessary(bean, beanName, cacheKey);&#10;            }&#10;        }&#10;        return bean;&#10;    }&#10;&#10;    public Object wrapIfNecessary(Object bean,String beanName,Object cacheKey){&#10;        //跳过AOP基础设施类，不进行代理&#10;        if (isInfrastructureClass(bean.getClass())) {&#10;            return bean;&#10;        }&#10;        //获取一个Bean的所有Advisor&#10;        Object[] advisors = getAdvicesAndAdvisorsForBean(beanName,bean.getClass());&#10;        if(advisors==DO_NOT_PROXY){&#10;            return bean;&#10;        }&#10;        log.info(&quot;AOP匹配成功,Bean名称:{}&quot;,beanName);&#10;        //创建代理&#10;        List&lt;PointcutAdvisor&gt;advisorsList=new ArrayList&lt;&gt;();&#10;        for (Object advisor : advisors) {&#10;            advisorsList.add((PointcutAdvisor) advisor);&#10;        }&#10;        /*ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();&#10;        proxyFactoryBean.setTarget(bean);&#10;        proxyFactoryBean.setBeanFactory(this.beanFactory);&#10;        //proxyFactoryBean.setAdvisors(advisorsList);&#10;        proxyFactoryBean.setAopProxyFactory(this.aopProxyFactory);*/&#10;        ProxyFactory proxyFactory=new ProxyFactory(bean);&#10;        proxyFactory.setAdvisors(advisorsList);&#10;        proxyFactory.setAopProxyFactory(this.aopProxyFactory);&#10;        return proxyFactory.getProxy();&#10;    }&#10;&#10;&#10;    //获取一个Bean最终要用的Advisor&#10;    private Object[] getAdvicesAndAdvisorsForBean(String beanName,Class&lt;?&gt; beanClass) {&#10;        List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanName,beanClass);&#10;        return advisors.isEmpty() ? DO_NOT_PROXY:advisors.toArray(new Advisor[0]);&#10;    }&#10;    private List&lt;Advisor&gt; findEligibleAdvisors(String beanName, Class&lt;?&gt; beanClass){&#10;        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(beanName,beanClass);&#10;        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors,beanClass);&#10;        return eligibleAdvisors;&#10;    }&#10;    //获取作用于特定Bean的动态的Advisor(在Spring中)&#10;    //然后另一个方法:resolveInterceptorNames是用来获取配置文件中的advisor,是全局的,固定好的&#10;    //但是minis只能通过配置文件来注册Advisor(笑)&#10;    private List&lt;Advisor&gt; findCandidateAdvisors(String beanName,Class&lt;?&gt; beanClass) {&#10;        if (advisorsCache != null) {&#10;            return advisorsCache;&#10;        }&#10;        List&lt;Advisor&gt; advisors=new ArrayList&lt;&gt;();&#10;        advisors.addAll(this.beanFactory.getBeansOfType(Advisor.class).values());&#10;        advisorsCache=advisors;&#10;        return advisors;&#10;    }&#10;    //判断Advisor是否适用于特定的Bean&#10;    private List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass) {&#10;        List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;();&#10;        for (Advisor advisor : candidateAdvisors) {&#10;            if (advisor instanceof PointcutAdvisor) {&#10;                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;&#10;                if(pointcutAdvisor instanceof PointcutAdvisor){&#10;                    //TODO 这里为啥莫名其妙空着了&#10;&#10;                }&#10;                //检查切点和该类是否匹配&#10;                if(AopUtils.canApply(pointcutAdvisor,beanClass)){&#10;                    //匹配成功,说明该类有需要被代理的方法(minis目前只能实现方法的代理)&#10;                    eligibleAdvisors.add(advisor);&#10;                }&#10;            }&#10;        }&#10;        return eligibleAdvisors;&#10;    }&#10;&#10;    @Override&#10;    public Object getEarlyBeanReference(Object bean, String beanName) {&#10;        // 跳过AOP基础设施类，避免在收集Advisor时再次走代理导致递归&#10;        if (isInfrastructureClass(bean.getClass())) {&#10;            return bean;&#10;        }&#10;        Object cacheKey = getCacheKey(bean.getClass(), beanName);&#10;        this.earlyProxyReferences.put(cacheKey, bean);&#10;        return wrapIfNecessary(bean, beanName, cacheKey);&#10;    }&#10;&#10;    protected Object getCacheKey(Class&lt;?&gt; beanClass,String beanName) {&#10;        if (StringUtils.hasLength(beanName)) {&#10;            return (FactoryBean.class.isAssignableFrom(beanClass) ?&#10;                    BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);&#10;        }&#10;        else {&#10;            return beanClass;&#10;        }&#10;    }&#10;    public boolean isInfrastructureClass(Class&lt;?&gt; beanClass) {&#10;        boolean retVal = Advice.class.isAssignableFrom(beanClass) ||&#10;                Pointcut.class.isAssignableFrom(beanClass) ||&#10;                Advisor.class.isAssignableFrom(beanClass);&#10;        return retVal;&#10;    }&#10;&#10;    @Override&#10;    public void setBeanFactory(BeanFactory beanFactory) {&#10;        this.beanFactory = (DefaultListableBeanFactory) beanFactory;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/minis/beans/factory/support/AbstractBeanFactory.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/minis/beans/factory/support/AbstractBeanFactory.java" />
              <option name="originalContent" value="package com.minis.beans.factory.support;&#10;&#10;import com.minis.beans.BeansException;&#10;import com.minis.beans.PropertyValue;&#10;import com.minis.beans.PropertyValues;&#10;import com.minis.beans.factory.BeanFactory;&#10;import com.minis.beans.factory.FactoryBean;&#10;import com.minis.beans.factory.config.BeanDefinition;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.lang.reflect.InvocationTargetException;&#10;import java.lang.reflect.Method;&#10;import java.lang.reflect.Proxy;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;@Slf4j&#10;public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements BeanFactory, BeanDefinitionRegistry {&#10;    private BeanFactory parentBeanFactory;&#10;    //改成了protected&#10;    protected Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);&#10;    protected List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;();&#10;    protected Map&lt;Class,String[]&gt; allBeanNamesByType = new ConcurrentHashMap&lt;&gt;();&#10;    List&lt;BeanDefinition&gt;nonLazyInitBeans =new ArrayList&lt;&gt;();&#10;&#10;    public AbstractBeanFactory(BeanFactory parentBeanFactory){&#10;        this.parentBeanFactory=parentBeanFactory;&#10;    }&#10;&#10;    public AbstractBeanFactory() {&#10;&#10;    }&#10;    /*普通bean创建逻辑:(AbstractBeanFactory为ab,AutowiredAbstractBeanFactory为aab,DefaultBeanRegistry为dbr&#10;    * ab:getBean-&gt;dbr:getSingleton(查询缓存版)-&gt;不在缓存中-&gt;ab:getSingleton(传入工厂对象)-&gt;调用工厂对象的getObject()&#10;    * aab:createBean-&gt;aab:createBeanInstance调用构造器创建原胚-&gt;aab:addSingletonFactory,把工厂对象放入缓存,同时这里工厂的getObject&#10;    * 绑定的是getEarlyBeanReference方法,注释会讲-&gt; aab:populateBean填充bean的属性.首先完成xml属性注入,然后调用SmartInstantiationAwareBeanPostProcessor,&#10;    * 调用每个后置处理器的postProcessProperties方法,其中调用完AutowiredAnnotationBeanPostProcessor&#10;    * 的postProcessProperties后完成Autowired注解注入.而一些后置处理器,比如AOP后置处理器,这个postProcessProperties&#10;    * 的实现是直接把参数原封不动返回了,即不做任何操作&#10;    * populateBean注入完属性后,就此完成bean的实例化-&gt;aab:initializeBean-&gt;调用每个后置处理器的postProcessBeforeInitialization&#10;    * -&gt;aab:invokeInitMethods(调用初始方法,不是构造方法而是自己定义的初始方法)-&gt;调用每个后置处理器的postProcessAfterInitialization*/&#10;&#10;    //getBean，容器的核心方法&#10;    public Object getBean(String beanName) throws BeansException {&#10;        //先尝试从缓存中直接拿bean实例&#10;        //TODO 在这加上对FactoryBean的识别逻辑&#10;        Object singleton = this.getSingleton(beanName);&#10;        //如果此时还没有这个bean的实例，则获取它的定义来创建实例&#10;        if (singleton == null) {&#10;            BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);&#10;            if (beanDefinition == null) {&#10;                throw new BeansException(&quot;No bean named '&quot; + beanName + &quot;' is defined&quot;);&#10;            }&#10;            singleton= this.getSingleton(beanName,()-&gt;{&#10;                return this.createBean(beanDefinition);&#10;            });&#10;        }&#10;        if (singleton instanceof FactoryBean) {&#10;            return this.getObjectForBeanInstance(singleton, beanName);&#10;        }&#10;        if(singleton!=null){&#10;            System.out.println(&quot;当前bean:&quot;+beanName+&quot;,是否是代理类:&quot;+Proxy.isProxyClass(singleton.getClass()));&#10;        }&#10;        return singleton;&#10;    }&#10;    /*TODO:这里代理方法的时序调用与Spring存在显著差异,AOP这块太复杂了,&#10;     * 已知的问题有getObjectForBeanInstance产生早早期代理,然后ostProcessBeforeInstantiation&#10;     * 产生早期代理,然后ostProcessAfterInstantiation完成最终代理,源码看麻了&#10;     */&#10;    protected abstract Object createBean(BeanDefinition beanDefinition) ;&#10;&#10;    protected void populateBean(BeanDefinition beanDefinition, Class&lt;?&gt; clz, Object obj){&#10;        //执行xml注入&#10;        handleProperties(beanDefinition, clz, obj);&#10;    }&#10;    private void handleProperties(BeanDefinition bd, Class&lt;?&gt; clz, Object obj) {&#10;        // 处理属性&#10;        PropertyValues propertyValues = bd.getPropertyValues();&#10;        //如果有属性&#10;        if (!propertyValues.isEmpty()) {&#10;            for (int i=0; i&lt;propertyValues.size(); i++) {&#10;                PropertyValue propertyValue = propertyValues.getPropertyValueList().get(i);&#10;                String pName = propertyValue.getName();&#10;                String pType = propertyValue.getType();&#10;                Object pValue = propertyValue.getValue();&#10;                boolean isRef = propertyValue.isRef();&#10;                Class&lt;?&gt;[] paramTypes = new Class&lt;?&gt;[1];&#10;                Object[] paramValues = new Object[1];&#10;                if (!isRef) { //如果不是ref，只是普通属性&#10;                    //对每一个属性，分数据类型分别处理&#10;                    if (&quot;String&quot;.equals(pType) || &quot;java.lang.String&quot;.equals(pType)) {&#10;                        paramTypes[0] = String.class;&#10;                    } else if (&quot;Integer&quot;.equals(pType) || &quot;java.lang.Integer&quot;.equals(pType)) {&#10;                        paramTypes[0] = Integer.class;&#10;                    } else if (&quot;int&quot;.equals(pType)) {&#10;                        paramTypes[0] = int.class;&#10;                    } else {&#10;                        paramTypes[0] = String.class;&#10;                    }&#10;                    paramValues[0] = pValue;&#10;                } else { //is ref, create the dependent beans&#10;                    try {&#10;                        paramTypes[0] = Class.forName(pType);&#10;                    } catch (ClassNotFoundException e) {&#10;                        e.printStackTrace();&#10;                    }&#10;                    //再次调用getBean创建ref的bean实例&#10;                    try {&#10;                        paramValues[0] = getBean((String) pValue);&#10;                    } catch (BeansException e) {&#10;                        throw new RuntimeException(e);&#10;                    }&#10;                }&#10;                //按照setXxxx规范查找setter方法，调用setter方法设置属性&#10;                String methodName = &quot;set&quot; + pName.substring(0, 1).toUpperCase() + pName.substring(1);&#10;                Method method = null;&#10;                try {&#10;                    method = clz.getMethod(methodName, paramTypes);&#10;                    method.invoke(obj, paramValues);&#10;                } catch (NoSuchMethodException e) {&#10;                    throw new RuntimeException(e);&#10;                } catch (InvocationTargetException e) {&#10;                    throw new RuntimeException(e);&#10;                } catch (IllegalAccessException e) {&#10;                    throw new RuntimeException(e);&#10;                }&#10;&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    @Override&#10;    public boolean containsBean(String name) {&#10;        return beanDefinitionMap.containsKey(name);&#10;    }&#10;    public String[] getBeanNamesByType(Class&lt;?&gt; type) throws BeansException {&#10;        //log.info(&quot;getBeanNamesByType:{}&quot;,type);&#10;        //检查是否在缓存中&#10;        String[] beanNames = allBeanNamesByType.get(type);&#10;        if(beanNames!=null){&#10;            return beanNames;&#10;        }&#10;        beanNames = doGetBeanNamesByType(type);&#10;        if(beanNames.length!=0){&#10;            //把结果加入缓存&#10;            allBeanNamesByType.put(type, beanNames);&#10;            return beanNames;&#10;        }&#10;        /*TODO:Spring的该方法是不会向父容器查找的,但是resolveDependency会向父容器查找,具体调用链比较复杂&#10;            日后再完善 */&#10;        if (parentBeanFactory != null) {&#10;            return ((AbstractBeanFactory)parentBeanFactory).getBeanNamesByType(type);&#10;        }else throw new BeansException(&quot;对应类型的Bean不存在,类型:&quot;+type);&#10;    }&#10;    //扫描所有的Bean,返回对应type(&#10;    private String[] doGetBeanNamesByType(Class&lt;?&gt; type) {&#10;        //TODO:完成对FactoryBean的检查&#10;        //log.info(&quot;doGetBeanNamesByType:{}&quot;,type);&#10;        List&lt;String&gt; beanNames = new ArrayList&lt;&gt;();&#10;        for (String beanName : beanDefinitionMap.keySet()) {&#10;            BeanDefinition bd = beanDefinitionMap.get(beanName);&#10;            Class&lt;?&gt; beanClass=bd.getBeanClass();&#10;            if (beanClass == type||type.isAssignableFrom(beanClass)) {&#10;                beanNames.add(beanName);&#10;            }&#10;        }&#10;        return beanNames.toArray(new String[0]);&#10;    }&#10;    //TODO 可能要加上对FactoryBean的识别逻辑&#10;    public void preInstantiateSingletons(){&#10;        for (BeanDefinition bd : nonLazyInitBeans) {&#10;            try {&#10;                getBean(bd.getId());&#10;            } catch (BeansException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        }&#10;    }&#10;&#10;    public void registerBeanDefinition(String name, BeanDefinition beanDefinition) {&#10;        this.beanDefinitionMap.put(name, beanDefinition);&#10;        this.beanDefinitionNames.add(name);&#10;        if (!beanDefinition.isLazyInit()) {&#10;            nonLazyInitBeans.add(beanDefinition);&#10;        }&#10;    }&#10;    public void removeBeanDefinition(String name) {&#10;        this.beanDefinitionMap.remove(name);&#10;        this.beanDefinitionNames.remove(name);&#10;        this.removeSingleton(name);&#10;    }&#10;    public BeanDefinition getBeanDefinition(String name) {&#10;        return this.beanDefinitionMap.get(name);&#10;    }&#10;    public boolean containsBeanDefinition(String name) {&#10;        return this.beanDefinitionMap.containsKey(name);&#10;    }&#10;    public boolean isSingleton(String name) {&#10;        return this.beanDefinitionMap.get(name).isSingleton();&#10;    }&#10;    public boolean isPrototype(String name) {&#10;        return this.beanDefinitionMap.get(name).isPrototype();&#10;    }&#10;    public Class&lt;?&gt; getType(String name) {&#10;        return this.beanDefinitionMap.get(name).getClass();&#10;    }&#10;&#10;    public List&lt;BeanDefinition&gt; getNonLazyInitBeans() {&#10;        return nonLazyInitBeans;&#10;    }&#10;&#10;    public void registerBean(String name, Object obj) {&#10;        this.registerSingleton(name, obj);&#10;    }&#10;&#10;    public BeanFactory getParentBeanFactory() {&#10;        return parentBeanFactory;&#10;    }&#10;&#10;    public void setParentBeanFactory(BeanFactory parentBeanFactory) {&#10;        this.parentBeanFactory = parentBeanFactory;&#10;    }&#10;&#10;    protected Object getObjectForBeanInstance(Object beanInstance, String beanName) {&#10;        // Now we have the bean instance, which may be a normal bean or a FactoryBean.&#10;        if (!(beanInstance instanceof FactoryBean)) {&#10;            return beanInstance;&#10;        }&#10;&#10;        Object object = null;&#10;        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;&#10;        object = getObjectFromFactoryBean(factory, beanName);&#10;        return object;&#10;    }&#10;&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.minis.beans.factory.support;&#10;&#10;import com.minis.beans.BeansException;&#10;import com.minis.beans.PropertyValue;&#10;import com.minis.beans.PropertyValues;&#10;import com.minis.beans.factory.BeanFactory;&#10;import com.minis.beans.factory.FactoryBean;&#10;import com.minis.beans.factory.config.BeanDefinition;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.lang.reflect.InvocationTargetException;&#10;import java.lang.reflect.Method;&#10;import java.lang.reflect.Proxy;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;@Slf4j&#10;public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements BeanFactory, BeanDefinitionRegistry {&#10;    private BeanFactory parentBeanFactory;&#10;    //改成了protected&#10;    protected Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);&#10;    protected List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;();&#10;    protected Map&lt;Class,String[]&gt; allBeanNamesByType = new ConcurrentHashMap&lt;&gt;();&#10;    List&lt;BeanDefinition&gt;nonLazyInitBeans =new ArrayList&lt;&gt;();&#10;&#10;    public AbstractBeanFactory(BeanFactory parentBeanFactory){&#10;        this.parentBeanFactory=parentBeanFactory;&#10;    }&#10;&#10;    public AbstractBeanFactory() {&#10;&#10;    }&#10;    /*普通bean创建逻辑:(AbstractBeanFactory为ab,AutowiredAbstractBeanFactory为aab,DefaultBeanRegistry为dbr&#10;    * ab:getBean-&gt;dbr:getSingleton(查询缓存版)-&gt;不在缓存中-&gt;ab:getSingleton(传入工厂对象)-&gt;调用工厂对象的getObject()&#10;    * aab:createBean-&gt;aab:createBeanInstance调用构造器创建原胚-&gt;aab:addSingletonFactory,把工厂对象放入缓存,同时这里工厂的getObject&#10;    * 绑定的是getEarlyBeanReference方法,注释会讲-&gt; aab:populateBean填充bean的属性.首先完成xml属性注入,然后调用SmartInstantiationAwareBeanPostProcessor,&#10;    * 调用每个后置处理器的postProcessProperties方法,其中调用完AutowiredAnnotationBeanPostProcessor&#10;    * 的postProcessProperties后完成Autowired注解注入.而一些后置处理器,比如AOP后置处理器,这个postProcessProperties&#10;    * 的实现是直接把参数原封不动返回了,即不做任何操作&#10;    * populateBean注入完属性后,就此完成bean的实例化-&gt;aab:initializeBean-&gt;调用每个后置处理器的postProcessBeforeInitialization&#10;    * -&gt;aab:invokeInitMethods(调用初始方法,不是构造方法而是自己定义的初始方法)-&gt;调用每个后置处理器的postProcessAfterInitialization*/&#10;&#10;    //getBean，容器的核心方法&#10;    public Object getBean(String beanName) throws BeansException {&#10;        //先尝试从缓存中直接拿bean实例&#10;        //TODO 在这加上对FactoryBean的识别逻辑&#10;        Object singleton = this.getSingleton(beanName);&#10;        //如果此时还没有这个bean的实例，则获取它的定义来创建实例&#10;        if (singleton == null) {&#10;            BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);&#10;            if (beanDefinition == null) {&#10;                throw new BeansException(&quot;No bean named '&quot; + beanName + &quot;' is defined&quot;);&#10;            }&#10;            singleton= this.getSingleton(beanName,()-&gt;{&#10;                return this.createBean(beanDefinition);&#10;            });&#10;        }&#10;        if (singleton instanceof FactoryBean) {&#10;            return this.getObjectForBeanInstance(singleton, beanName);&#10;        }&#10;        if(singleton!=null){&#10;            System.out.println(&quot;当前bean:&quot;+beanName+&quot;,是否是代理类:&quot;+Proxy.isProxyClass(singleton.getClass()));&#10;        }&#10;        return singleton;&#10;    }&#10;    /*TODO:这里代理方法的时序调用与Spring存在显著差异,AOP这块太复杂了,&#10;     * 已知的问题有getObjectForBeanInstance产生早早期代理,然后ostProcessBeforeInstantiation&#10;     * 产生早期代理,然后ostProcessAfterInstantiation完成最终代理,源码看麻了&#10;     */&#10;    protected abstract Object createBean(BeanDefinition beanDefinition) ;&#10;&#10;    protected void populateBean(BeanDefinition beanDefinition, Class&lt;?&gt; clz, Object obj){&#10;        //执行xml注入&#10;        handleProperties(beanDefinition, clz, obj);&#10;    }&#10;    private void handleProperties(BeanDefinition bd, Class&lt;?&gt; clz, Object obj) {&#10;        // 处理属性&#10;        PropertyValues propertyValues = bd.getPropertyValues();&#10;        //如果有属性&#10;        if (!propertyValues.isEmpty()) {&#10;            for (int i=0; i&lt;propertyValues.size(); i++) {&#10;                PropertyValue propertyValue = propertyValues.getPropertyValueList().get(i);&#10;                String pName = propertyValue.getName();&#10;                String pType = propertyValue.getType();&#10;                Object pValue = propertyValue.getValue();&#10;                boolean isRef = propertyValue.isRef();&#10;                Class&lt;?&gt;[] paramTypes = new Class&lt;?&gt;[1];&#10;                Object[] paramValues = new Object[1];&#10;                if (!isRef) { //如果不是ref，只是普通属性&#10;                    //对每一个属性，分数据类型分别处理&#10;                    if (&quot;String&quot;.equals(pType) || &quot;java.lang.String&quot;.equals(pType)) {&#10;                        paramTypes[0] = String.class;&#10;                    } else if (&quot;Integer&quot;.equals(pType) || &quot;java.lang.Integer&quot;.equals(pType)) {&#10;                        paramTypes[0] = Integer.class;&#10;                    } else if (&quot;int&quot;.equals(pType)) {&#10;                        paramTypes[0] = int.class;&#10;                    } else {&#10;                        paramTypes[0] = String.class;&#10;                    }&#10;                    paramValues[0] = pValue;&#10;                } else { //is ref, create the dependent beans&#10;                    try {&#10;                        paramTypes[0] = Class.forName(pType);&#10;                    } catch (ClassNotFoundException e) {&#10;                        e.printStackTrace();&#10;                    }&#10;                    //再次调用getBean创建ref的bean实例&#10;                    try {&#10;                        paramValues[0] = getBean((String) pValue);&#10;                    } catch (BeansException e) {&#10;                        throw new RuntimeException(e);&#10;                    }&#10;                }&#10;                //按照setXxxx规范查找setter方法，调用setter方法设置属性&#10;                String methodName = &quot;set&quot; + pName.substring(0, 1).toUpperCase() + pName.substring(1);&#10;                Method method = null;&#10;                try {&#10;                    method = clz.getMethod(methodName, paramTypes);&#10;                    method.invoke(obj, paramValues);&#10;                } catch (NoSuchMethodException e) {&#10;                    throw new RuntimeException(e);&#10;                } catch (InvocationTargetException e) {&#10;                    throw new RuntimeException(e);&#10;                } catch (IllegalAccessException e) {&#10;                    throw new RuntimeException(e);&#10;                }&#10;&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    @Override&#10;    public boolean containsBean(String name) {&#10;        return beanDefinitionMap.containsKey(name);&#10;    }&#10;    public String[] getBeanNamesByType(Class&lt;?&gt; type) throws BeansException {&#10;        //log.info(&quot;getBeanNamesByType:{}&quot;,type);&#10;        //检查是否在缓存中&#10;        String[] beanNames = allBeanNamesByType.get(type);&#10;        if(beanNames!=null){&#10;            return beanNames;&#10;        }&#10;        beanNames = doGetBeanNamesByType(type);&#10;        if(beanNames.length!=0){&#10;            //把结果加入缓存&#10;            allBeanNamesByType.put(type, beanNames);&#10;            return beanNames;&#10;        }&#10;        /*TODO:Spring的该方法是不会向父容器查找的,但是resolveDependency会向父容器查找,具体调用链比较复杂&#10;            日后再完善 */&#10;        if (parentBeanFactory != null) {&#10;            return ((AbstractBeanFactory)parentBeanFactory).getBeanNamesByType(type);&#10;        }else throw new BeansException(&quot;对应类型的Bean不存在,类型:&quot;+type);&#10;    }&#10;    //扫描所有的Bean,返回对应type(&#10;    private String[] doGetBeanNamesByType(Class&lt;?&gt; type) {&#10;        //TODO:完成对FactoryBean的检查&#10;        //log.info(&quot;doGetBeanNamesByType:{}&quot;,type);&#10;        List&lt;String&gt; beanNames = new ArrayList&lt;&gt;();&#10;        for (String beanName : beanDefinitionMap.keySet()) {&#10;            BeanDefinition bd = beanDefinitionMap.get(beanName);&#10;            Class&lt;?&gt; beanClass=bd.getBeanClass();&#10;            if (beanClass == type||type.isAssignableFrom(beanClass)) {&#10;                beanNames.add(beanName);&#10;            }&#10;        }&#10;        return beanNames.toArray(new String[0]);&#10;    }&#10;    //TODO 可能要加上对FactoryBean的识别逻辑&#10;    public void preInstantiateSingletons(){&#10;        for (BeanDefinition bd : nonLazyInitBeans) {&#10;            try {&#10;                getBean(bd.getId());&#10;            } catch (BeansException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        }&#10;    }&#10;&#10;    public void registerBeanDefinition(String name, BeanDefinition beanDefinition) {&#10;        this.beanDefinitionMap.put(name, beanDefinition);&#10;        this.beanDefinitionNames.add(name);&#10;        if (!beanDefinition.isLazyInit()) {&#10;            nonLazyInitBeans.add(beanDefinition);&#10;        }&#10;    }&#10;    public void removeBeanDefinition(String name) {&#10;        this.beanDefinitionMap.remove(name);&#10;        this.beanDefinitionNames.remove(name);&#10;        this.removeSingleton(name);&#10;    }&#10;    public BeanDefinition getBeanDefinition(String name) {&#10;        return this.beanDefinitionMap.get(name);&#10;    }&#10;    public boolean containsBeanDefinition(String name) {&#10;        return this.beanDefinitionMap.containsKey(name);&#10;    }&#10;    public boolean isSingleton(String name) {&#10;        return this.beanDefinitionMap.get(name).isSingleton();&#10;    }&#10;    public boolean isPrototype(String name) {&#10;        return this.beanDefinitionMap.get(name).isPrototype();&#10;    }&#10;    public Class&lt;?&gt; getType(String name) {&#10;        return this.beanDefinitionMap.get(name).getClass();&#10;    }&#10;&#10;    public List&lt;BeanDefinition&gt; getNonLazyInitBeans() {&#10;        return nonLazyInitBeans;&#10;    }&#10;&#10;    public void registerBean(String name, Object obj) {&#10;        this.registerSingleton(name, obj);&#10;    }&#10;&#10;    public BeanFactory getParentBeanFactory() {&#10;        return parentBeanFactory;&#10;    }&#10;&#10;    public void setParentBeanFactory(BeanFactory parentBeanFactory) {&#10;        this.parentBeanFactory = parentBeanFactory;&#10;    }&#10;&#10;    protected Object getObjectForBeanInstance(Object beanInstance, String beanName) {&#10;        // Now we have the bean instance, which may be a normal bean or a FactoryBean.&#10;        if (!(beanInstance instanceof FactoryBean)) {&#10;            return beanInstance;&#10;        }&#10;&#10;        Object object = null;&#10;        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;&#10;        object = getObjectFromFactoryBean(factory, beanName);&#10;        return object;&#10;    }&#10;&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/applicationContext.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/applicationContext.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&#10;&lt;beans&gt;&#10;    &lt;bean id=&quot;autoProxyCreator&quot; class=&quot;com.minis.aop.ProxyCreator&quot; &gt;&#10;&#10;&#10;    &lt;/bean&gt;&#10;    &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.minis.test.service.MyBeforeAdvice&quot; /&gt;&#10;    &lt;bean id=&quot;advisor&quot; class=&quot;com.minis.aop.NameMatchMethodPointcutAdvisor&quot;&gt;&#10;        &lt;property type=&quot;com.minis.aop.Advice&quot; name=&quot;advice&quot; ref=&quot;beforeAdvice&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;mappedName&quot; value=&quot;does*&quot;/&gt;&#10;    &lt;/bean&gt;&#10;    &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.minis.test.service.TracingInterceptor&quot; /&gt;&#10;    &lt;bean id=&quot;realaction&quot; class=&quot;com.minis.test.service.Action1&quot; /&gt;&#10;&#10;    &lt;bean id=&quot;baseBaseService&quot; class=&quot;com.minis.test.BaseBaseService&quot;&gt;&#10;        &lt;property type=&quot;com.minis.test.AServiceImpl&quot; name=&quot;as&quot; ref=&quot;aService&quot; /&gt;&#10;    &lt;/bean&gt;&#10;    &lt;bean id=&quot;aService&quot; class=&quot;com.minis.test.AServiceImpl&quot;&gt;&#10;        &lt;constructor-arg type=&quot;String&quot; name=&quot;name&quot; value=&quot;abc&quot;/&gt;&#10;        &lt;constructor-arg type=&quot;int&quot; name=&quot;level&quot; value=&quot;3&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;property1&quot; value=&quot;Someone says&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;property2&quot; value=&quot;Hello World!&quot;/&gt;&#10;        &lt;!--        &lt;property type=&quot;com.minis.test.BaseService&quot; name=&quot;ref1&quot; ref=&quot;baseService&quot;/&gt;--&gt;&#10;    &lt;/bean&gt;&#10;    &lt;bean id=&quot;baseService&quot; class=&quot;com.minis.test.BaseService&quot;&gt;&#10;    &lt;/bean&gt;&#10;&#10;&#10;&lt;!--    &lt;bean id=&quot;action&quot; class=&quot;com.minis.aop.ProxyFactoryBean&quot; &gt;--&gt;&#10;&lt;!--        &lt;property type=&quot;java.lang.Object&quot; name=&quot;target&quot; ref=&quot;realaction&quot;/&gt;--&gt;&#10;&lt;!--    &lt;/bean&gt;--&gt;&#10;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.minis.jdbc.datasource.SingleConnectionDataSource&quot;&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;driverClassName&quot; value=&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;url&quot; value=&quot;jdbc:sqlserver://localhost:1433;databasename=DEMO;&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;username&quot; value=&quot;sa&quot;/&gt;&#10;        &lt;property type=&quot;String&quot; name=&quot;password&quot; value=&quot;Sql2016&quot;/&gt;&#10;    &lt;/bean&gt;&#10;    &lt;bean id=&quot;webBindingInitializer&quot; class=&quot;com.minis.test.DateInitializer&quot;&gt;&#10;    &lt;/bean&gt;&#10;&#10;&#10;&#10;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;com.minis.jdbc.core.JdbcTemplate&quot; &gt;&#10;        &lt;property type=&quot;javax.sql.DataSource&quot; name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&#10;    &lt;/bean&gt;&#10;&#10;&#10;&lt;/beans&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&#13;&#10;&lt;beans&gt;&#13;&#10;    &lt;bean id=&quot;autoProxyCreator&quot; class=&quot;com.minis.aop.ProxyCreator&quot; &gt;&#13;&#10;&#13;&#10;&#13;&#10;    &lt;/bean&gt;&#13;&#10;    &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.minis.test.service.MyBeforeAdvice&quot; /&gt;&#13;&#10;    &lt;bean id=&quot;advisor&quot; class=&quot;com.minis.aop.NameMatchMethodPointcutAdvisor&quot;&gt;&#13;&#10;        &lt;property type=&quot;com.minis.aop.Advice&quot; name=&quot;advice&quot; ref=&quot;beforeAdvice&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;mappedName&quot; value=&quot;does*&quot;/&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;    &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.minis.test.service.TracingInterceptor&quot; /&gt;&#13;&#10;    &lt;bean id=&quot;realaction&quot; class=&quot;com.minis.test.service.Action1&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;bean id=&quot;baseBaseService&quot; class=&quot;com.minis.test.BaseBaseService&quot;&gt;&#13;&#10;        &lt;property type=&quot;com.minis.test.AServiceImpl&quot; name=&quot;as&quot; ref=&quot;aService&quot; /&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;    &lt;bean id=&quot;aService&quot; class=&quot;com.minis.test.AServiceImpl&quot;&gt;&#13;&#10;        &lt;constructor-arg type=&quot;String&quot; name=&quot;name&quot; value=&quot;abc&quot;/&gt;&#13;&#10;        &lt;constructor-arg type=&quot;int&quot; name=&quot;level&quot; value=&quot;3&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;property1&quot; value=&quot;Someone says&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;property2&quot; value=&quot;Hello World!&quot;/&gt;&#13;&#10;        &lt;!--        &lt;property type=&quot;com.minis.test.BaseService&quot; name=&quot;ref1&quot; ref=&quot;baseService&quot;/&gt;--&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;    &lt;bean id=&quot;baseService&quot; class=&quot;com.minis.test.BaseService&quot;&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;&#13;&#10;&#13;&#10;&lt;!--    &lt;bean id=&quot;action&quot; class=&quot;com.minis.aop.ProxyFactoryBean&quot; &gt;--&gt;&#13;&#10;&lt;!--        &lt;property type=&quot;java.lang.Object&quot; name=&quot;target&quot; ref=&quot;realaction&quot;/&gt;--&gt;&#13;&#10;&lt;!--    &lt;/bean&gt;--&gt;&#13;&#10;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.minis.jdbc.datasource.SingleConnectionDataSource&quot;&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;driverClassName&quot; value=&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;url&quot; value=&quot;jdbc:sqlserver://localhost:1433;databasename=DEMO;&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;username&quot; value=&quot;sa&quot;/&gt;&#13;&#10;        &lt;property type=&quot;String&quot; name=&quot;password&quot; value=&quot;Sql2016&quot;/&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;    &lt;bean id=&quot;webBindingInitializer&quot; class=&quot;com.minis.test.DateInitializer&quot;&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;com.minis.jdbc.core.JdbcTemplate&quot; &gt;&#13;&#10;        &lt;property type=&quot;javax.sql.DataSource&quot; name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&#13;&#10;    &lt;/bean&gt;&#13;&#10;&#13;&#10;&#13;&#10;&lt;/beans&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>